<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Logo Showcase</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            position: fixed; /* Prevent scroll on mobile */
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Disable touch gestures */
        }
        
        .logo-container {
            position: absolute;
            z-index: 10;
            pointer-events: none;
        }
        
        .logo {
            width: min(200px, 60vw, 60vh);
            height: min(200px, 60vw, 60vh);
            filter: drop-shadow(0 0 30px rgba(255, 215, 0, 0.3));
        }
        
        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .shape-cell {
            position: absolute;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .shape {
            width: 32px;
            height: 32px;
        }
        
        .shape path {
            fill: #2a2a2a;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div class="grid-container" id="grid"></div>
    
    <div class="logo-container">
        <img class="logo" src="./logo.svg" alt="logo">
    </div>

    <script>
"use strict";
class Shape {
    constructor(x, y, id, shapePaths) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.shapePaths = shapePaths;
        this.element = this.createElement();
    }

    createElement = () => {
        const cell = document.createElement('div');
        cell.className = 'shape-cell';
        cell.id = `shape-${this.id}`;
        cell.style.left = `${this.x}px`;
        cell.style.top = `${this.y}px`;

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'shape');
        svg.setAttribute('viewBox', '0 0 7 7');
        svg.setAttribute('width', '24');
        svg.setAttribute('height', '24');

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', this.getRandomShape());
        path.setAttribute('fill', '#2a2a2a');
        path.setAttribute('opacity', '0.3');

        svg.appendChild(path);
        cell.appendChild(svg);
        return cell;
    }

    getRandomShape = () => {
        const randomIndex = Math.floor(Math.random() * this.shapePaths.length);
        return this.shapePaths[randomIndex];
    }

    updatePosition(moveSpeed) {
        this.x -= moveSpeed;
        this.y += moveSpeed;
        this.element.style.left = `${this.x}px`;
        this.element.style.top = `${this.y}px`;
    }

    applyCursorEffect(mouseX, mouseY, influenceRadius, cellSize) {
        const shapeCenterX = this.x + cellSize / 2;
        const shapeCenterY = this.y + cellSize / 2;
        const distance = Math.hypot(mouseX - shapeCenterX, mouseY - shapeCenterY);
        let scale = 1.0;
        if (distance < influenceRadius) {
            const influence = 1 - (distance / influenceRadius);
            scale = 1.0 + (influence * 0.4); // Scale up to 1.4x
        }
        this.element.style.transform = `scale(${scale})`;
        this.element.style.transition = 'transform 0.3s ease-out';
    }
}

class ShapeGrid {
    shapePaths;
    gridSpacing;
    cellSize;
    moveSpeed;
    influenceRadius;
    gridContainer;
    shapes = [];
    shapeIdCounter = 0;
    mouseX = window.innerWidth / 2;
    mouseY = window.innerHeight / 2;
    isMobile;
    frameSkip = this.isMobile ? 2 : 1;
    frameCounter = 0;
    resizeTimeout = null;
    screenWidth;
    screenHeight;
    minX;
    maxX;
    minY;
    maxY;
    allowedMinX;
    allowedMinY;
    allowedMaxX;
    allowedMaxY;

    constructor(options) {
        ({
            shapePaths: this.shapePaths,
            gridSpacing: this.gridSpacing,
            cellSize: this.cellSize,
            moveSpeed: this.moveSpeed,
            influenceRadius: this.influenceRadius,
            gridContainerId: this.gridContainerId
        } = options);
        this.gridContainer = document.getElementById(this.gridContainerId);
    }

    initializeGrid = () => {
        this.screenWidth = window.innerWidth;
        this.screenHeight = window.innerHeight;

        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || this.screenWidth <= 768 || ('ontouchstart' in window);
        if(this.isMobile) {
            console.log('Mobile device detected, adjusting settings.');
        }

        this.allowedMinX = -this.gridSpacing;
        this.allowedMinY = -this.gridSpacing;
        this.allowedMaxX = this.screenWidth + this.gridSpacing;
        this.allowedMaxY = this.screenHeight + this.gridSpacing;
        
        const fragment = document.createDocumentFragment();
        let x, y;
        for (x=this.allowedMinX; x<this.allowedMaxX; x+=this.gridSpacing) {
            for (y=this.allowedMaxY; y>this.allowedMinY; y-=this.gridSpacing) {
                const shape = new Shape(x, y, this.shapeIdCounter++, this.shapePaths);
                this.shapes.push(shape);
                fragment.appendChild(shape.element);
            }
        }
        this.gridContainer.appendChild(fragment);

        this.minX = this.allowedMinX;
        this.maxX = x-this.gridSpacing;
        this.minY = y+this.gridSpacing;
        this.maxY = this.allowedMaxY;
    }

    addNewShapesAtEdges = () => {
        // Add new column on the right if needed
        if (this.maxX < this.allowedMaxX) {
            this.maxX += this.gridSpacing;
            const fragment = document.createDocumentFragment();
            for (let y=this.maxY; y>=this.minY; y-=this.gridSpacing) {
                const shape = new Shape(this.maxX, y, this.shapeIdCounter++, this.shapePaths);
                this.shapes.push(shape);
                fragment.appendChild(shape.element);
            }
            this.gridContainer.appendChild(fragment);
        }
        // Add new row at the top if needed
        if (this.minY > this.allowedMinY) {
            this.minY -= this.gridSpacing;
            const fragment = document.createDocumentFragment();
            for (let x=this.minX; x<=this.maxX; x+=this.gridSpacing) {
                const shape = new Shape(x, this.minY, this.shapeIdCounter++, this.shapePaths);
                this.shapes.push(shape);
                fragment.appendChild(shape.element);
            }
            this.gridContainer.appendChild(fragment);
        }
    }

    updateShapePositions = () => {
        this.minX -= this.moveSpeed;
        this.maxX -= this.moveSpeed;
        this.minY += this.moveSpeed;
        this.maxY += this.moveSpeed;
        if (this.minX<this.allowedMinX) this.minX += this.gridSpacing;
        if (this.maxY>this.allowedMaxY) this.maxY -= this.gridSpacing;

        this.shapes = this.shapes.filter(shape => {
            shape.updatePosition(this.moveSpeed);
            if (!this.isMobile) {
                shape.applyCursorEffect(this.mouseX, this.mouseY, this.influenceRadius, this.cellSize);
            }
            
            if (shape.x < this.allowedMinX || shape.y > this.allowedMaxY) {
                this.gridContainer.removeChild(shape.element);
                return false;
            }
            return true;
        });
    }

    animate = () => {
        this.frameCounter++;
        if (this.frameCounter % this.frameSkip === 0) {
            this.updateShapePositions();
            this.addNewShapesAtEdges();
        }
        requestAnimationFrame(this.animate);
    }

    handleResize = () => {
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                while (this.gridContainer.firstChild) {
                    this.gridContainer.removeChild(this.gridContainer.firstChild);
                }
                this.shapes = [];
                this.shapeIdCounter = 0;
                this.initializeGrid();
            }, 200);
        });
    }

    trackMouseMovement = () => {
        if (!this.isMobile) {
            document.addEventListener('mousemove', ({ clientX, clientY }) => {
                this.mouseX = clientX;
                this.mouseY = clientY;
            });
        }
    }

    start = () => {
        this.initializeGrid();
        this.trackMouseMovement();
        this.handleResize();
        this.animate();
    }
}

// --- Initialize and start the grid ---
const grid = new ShapeGrid({
    shapePaths: [
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
        'M6.5 0 A6.5 6.5 0 0 0 0 6.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L6.5 0 z',
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 6.5 A6.5 6.5 0 0 0 0.5 0 L0.5 0 z',
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L0.5 7 A6.5 6.5 0 0 0 7 0.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 0.5 A6.5 6.5 0 0 0 6.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
        'M6.5 0 A6.5 6.5 0 0 0 0 6.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L0.5 7 A6.5 6.5 0 0 0 7 0.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L6.5 0 z',
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 0.5 A6.5 6.5 0 0 0 6.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 6.5 A6.5 6.5 0 0 0 0.5 0 L0.5 0 z',
        'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z',
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L0.5 0 z',
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
        'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L3.5 0 z',
        'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L0.5 0 z',
        'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L3.5 0 z',
        'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z',
        'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z',
        'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z'
    ],
    gridSpacing: 65,
    cellSize: 50,
    moveSpeed: 0.4,
    influenceRadius: 150,
    gridContainerId: 'grid'
});
grid.start();
    </script>
</body>
</html>