<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Endless Moving Shapes Grid</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            position: fixed; /* Prevent scroll on mobile */
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Disable touch gestures */
        }
        
        .logo-container {
            position: absolute;
            z-index: 10;
            pointer-events: none;
        }
        
        .logo {
            width: min(200px, 60vw, 60vh);
            height: min(200px, 60vw, 60vh);
            filter: drop-shadow(0 0 30px rgba(255, 215, 0, 0.3));
        }
        
        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .shape-cell {
            position: absolute;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .shape {
            width: 32px;
            height: 32px;
        }
        
        .shape path {
            fill: #2a2a2a;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div class="grid-container" id="grid"></div>
    
    <div class="logo-container">
        <img class="logo" src="./logo.svg" alt="logo">
    </div>

    <script>
        const shapePaths = [
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
            'M6.5 0 A6.5 6.5 0 0 0 0 6.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L6.5 0 z',
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 6.5 A6.5 6.5 0 0 0 0.5 0 L0.5 0 z',
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L0.5 7 A6.5 6.5 0 0 0 7 0.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 0.5 A6.5 6.5 0 0 0 6.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
            'M6.5 0 A6.5 6.5 0 0 0 0 6.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L0.5 7 A6.5 6.5 0 0 0 7 0.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L6.5 0 z',
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 0.5 A6.5 6.5 0 0 0 6.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 6.5 A6.5 6.5 0 0 0 0.5 0 L0.5 0 z',
            'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z',
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L0.5 0 z',
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L0.5 0 z',
            'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L3.5 0 z',
            'M0.5 0 A0.5 0.5 0 0 0 0 0.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L0.5 0 z',
            'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 0.5 A0.5 0.5 0 0 0 6.5 0 L3.5 0 z',
            'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L6.5 7 A0.5 0.5 0 0 0 7 6.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z',
            'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 6.5 A0.5 0.5 0 0 0 0.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z',
            'M3.5 0 A3.5 3.5 0 0 0 0 3.5 L0 3.5 A3.5 3.5 0 0 0 3.5 7 L3.5 7 A3.5 3.5 0 0 0 7 3.5 L7 3.5 A3.5 3.5 0 0 0 3.5 0 L3.5 0 z'
        ];

        let shapes = [];
        let shapeIdCounter = 0;
        const cellSize = 50;
        const gap = 15;
        const gridSpacing = cellSize + gap;
        const moveSpeed = 0.2; // pixels per frame
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        const influenceRadius = 150; // radius in pixels where cursor affects shapes
        
        // Mobile detection and optimization
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768 || ('ontouchstart' in window);
        
        // Reduce performance load on mobile
        const frameSkip = isMobile ? 2 : 1; // Skip every other frame on mobile
        let frameCounter = 0;

        function getRandomShape() {
            const randomIndex = Math.floor(Math.random() * shapePaths.length);
            return shapePaths[randomIndex];
        }

        function createShapeElement(x, y) {
            const cell = document.createElement('div');
            cell.className = 'shape-cell';
            cell.id = `shape-${shapeIdCounter++}`;
            cell.style.left = x + 'px';
            cell.style.top = y + 'px';

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'shape');
            svg.setAttribute('viewBox', '0 0 7 7');
            svg.setAttribute('width', '24');
            svg.setAttribute('height', '24');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', getRandomShape());
            path.setAttribute('fill', '#2a2a2a');
            path.setAttribute('opacity', '0.3');

            svg.appendChild(path);
            cell.appendChild(svg);
            // Do not append to DOM here
            return {
                element: cell,
                x: x,
                y: y,
                id: cell.id
            };
        }

        function initializeGrid() {
            const cols = Math.ceil(window.innerWidth / gridSpacing) + 2; // +2 for buffer
            const rows = Math.ceil(window.innerHeight / gridSpacing) + 2; // +2 for buffer

            if (cols < 1 || rows < 1) return;

            // Start grid slightly off-screen to the top-right
            const startX = -gridSpacing;
            const startY = -gridSpacing;

            const fragment = document.createDocumentFragment();
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = startX + col * gridSpacing;
                    const y = startY + row * gridSpacing;
                    const shape = createShapeElement(x, y);
                    shapes.push(shape);
                    fragment.appendChild(shape.element);
                }
            }
            document.getElementById('grid').appendChild(fragment);
        }

        function addNewShapesAtEdges() {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;

            // Find the boundary positions
            let maxX = -Infinity;
            let minY = Infinity;
            let minX = Infinity;

            shapes.forEach(shape => {
                if (shape.x > maxX) maxX = shape.x;
                if (shape.y < minY) minY = shape.y;
                if (shape.x < minX) minX = shape.x;
            });

            // Add new column on the right if needed
            if (maxX < screenWidth + gridSpacing) {
                const newX = maxX + gridSpacing;
                const rows = Math.ceil(window.innerHeight / gridSpacing) + 2; //todo: declare outside to reuse with initialize grid
                const startY = minY;
                const fragment = document.createDocumentFragment();
                for (let row = 0; row < rows; row++) {
                    const y = startY + row * gridSpacing;
                    const shape = createShapeElement(newX, y);
                    shapes.push(shape);
                    fragment.appendChild(shape.element);
                }
                document.getElementById('grid').appendChild(fragment);
            }

            // Add new row at the top if needed
            if (minY > -gridSpacing) {
                const newY = minY - gridSpacing;
                const cols = Math.ceil(window.innerWidth / gridSpacing) + 2;
                const fragment = document.createDocumentFragment();
                for (let col = 0; col < cols; col++) {
                    const x = minX + col * gridSpacing;
                    const shape = createShapeElement(x, newY);
                    shapes.push(shape);
                    fragment.appendChild(shape.element);
                }
                document.getElementById('grid').appendChild(fragment);
            }
        }

        function removeOffscreenShapes() {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;

            const fragment = document.createDocumentFragment();
            shapes = shapes.filter(shape => {
                if (shape.x < -gridSpacing || shape.y > screenHeight + gridSpacing) {
                    fragment.appendChild(shape.element); // Detach from DOM in batch
                    return false;
                }
                return true;
            });
            // Remove all collected elements from DOM in one operation
            fragment.textContent = '';
        }

        function updateShapePositions() {
            shapes.forEach(shape => {
                shape.x -= moveSpeed;
                shape.y += moveSpeed;
                shape.element.style.left = shape.x + 'px';
                shape.element.style.top = shape.y + 'px';
                
                // Skip cursor effect on mobile for performance
                if (!isMobile) {
                    // Calculate distance from cursor
                    const shapeCenterX = shape.x + cellSize / 2;
                    const shapeCenterY = shape.y + cellSize / 2;
                    const distance = Math.sqrt(
                        Math.pow(mouseX - shapeCenterX, 2) + 
                        Math.pow(mouseY - shapeCenterY, 2)
                    );
                    
                    // Calculate scale based on distance (1.0 to 1.2)
                    let scale = 1.0;
                    if (distance < influenceRadius) {
                        const influence = 1 - (distance / influenceRadius);
                        scale = 1.0 + (influence * 0.2); // 20% max increase
                    }
                    
                    // Apply scale with smooth transition
                    shape.element.style.transform = `scale(${scale})`;
                    shape.element.style.transition = 'transform 0.3s ease-out';
                } else {
                    // Reset any scaling on mobile
                    shape.element.style.transform = 'scale(1)';
                    shape.element.style.transition = 'none';
                }
            });
        }

        function animate() {
            frameCounter++;
            
            // Skip frames on mobile for better performance
            if (frameCounter % frameSkip === 0) {
                updateShapePositions();
                addNewShapesAtEdges();
                removeOffscreenShapes();
            }
            
            requestAnimationFrame(animate);
        }

        // Track mouse movement (desktop only)
        if (!isMobile) {
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
        }

        // Initialize and start animation
        initializeGrid();
        animate();

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                shapes.forEach(shape => shape.element.remove());
                shapes = [];
                shapeIdCounter = 0;
                initializeGrid();
            }, 200);
        });
    </script>
</body>
</html>